# 2025-08-15

Added `wsl:` command to the TUI.

- What I did
	- Implemented `wsl:` handling in `src/conch/tui.py` so that:
		- On Windows the command is run inside the default WSL (`wsl <cmd>`).
		- On other OSes the command is forwarded to the regular shell handler.
	- Updated the `HELP_TEXT` in `src/conch/tui.py` to document `wsl:`.

- Files changed
	- `src/conch/tui.py` — added `wsl:` handling and help text update

- Test/verification
	- Ran the test suite: 3 passed (see `uv run pytest tests`).

- Notes / next steps
	- `mvp.py` still differs from `tui.py` (no `wsl:` in MVP, `mvp` supports `py:` and `:ai`).
	- If parity is desired we can either add `py:`/`:ai` to the TUI or add the file/command helpers from the TUI into `mvp.py`.

Short and focused entry for today — will extend later if we add parity changes.

## note

In `mvp` you can use `sh: cat filename` or `sh: ls filename` (it doesn't replace the log)

Try to figure out the dominant mode (sh, py, wsl, ai, sam).
Or allow the user to switch easily. Julia repl does this. Also [some python repl]. Switch between command and help browser modes.

### List of alternate Python repls

Here are concise options to consider for replacing or augmenting the tiny `PyExec` used in `mvp.py`:

- CPython interactive REPL (stock)
	- The built-in `python` interactive prompt. Lightweight and always available. Good for simple eval/exec flows.

- IPython
	- Feature-rich: better history, tab-completion, `%magic` commands, rich display, and easy introspection. Useful when users want a full-featured interactive experience inside the app.

- bpython
	- Lightweight, curses-based REPL with in-line autocompletion, syntax highlighting, and rewindable input. Excellent for a nicer CLI REPL without the full IPython weight.

- ptpython / prompt_toolkit REPL
	- Pluggable, embeddable REPL built on `prompt_toolkit`. Offers async support, multiline editing, and customizable keybindings. Good if you want to embed a powerful editor-like prompt.

- Jedi-based embeddable completion
	- Use `jedi` to provide smarter completions and go-to-definition within a custom REPL wrapper. Combine with `prompt_toolkit` for an IDE-like prompt.

- bpython-urwid or textual integration
	- Integrate a REPL into a TUI framework (Textual, urwid) for visual embedding in the `tui.py` interface. Textual's `Input` + a shared Python context + `ptpython` style editing can work well.

- PyREPL / code.InteractiveConsole (stdlib)
	- The `code` module (`code.InteractiveConsole`) is easy to embed and control execution; it gives programmatic access to push lines and capture output. Minimal dependency and flexible.

- Xonsh
	- Hybrid shell/REPL (Python-powered shell). If you want shell features plus Python, xonsh mixes both worlds — heavier but powerful for shell + Python workflows.

- Micro-VM or sandboxed interpreters (Pyodide, Skulpt)
	- For sandboxed or browser-based execution contexts, `pyodide` (WebAssembly) or `skulpt` (JS) let you run Python safely in constrained environments.

Notes:
- For `mvp.py` the simplest upgrades are: use `code.InteractiveConsole` (stdlib) to preserve embedding control, or `IPython`/`ptpython` for a much nicer interactive UX.
- If the goal is parity with the TUI, consider embedding a `ptpython` session or using `prompt_toolkit`-based input handling so the REPL behavior can map to both CLI `mvp` and `tui` components.

## Modality of Input

The app starts in shell mode, but you can switch to python mode (and back).
Slash commands work the same in all modes.
We can drop the sh: and py: prefixes.

### Implementation Plan

- Define the style for the modes.
- Implement mode switching.

### Implementation

Added input modalities (shell and python modes) with color-coded input borders.
Shell mode now uses a green border (#44CC88), python mode uses orange (#CC8844).
Switching modes updates the input field's border color and style for clarity.